
---

### Ficheiro 2: `TODO.md`

```markdown
# Plano de Trabalho / TODO

Este ficheiro é o plano de implementação passo a passo.

---

## 0. Preparação inicial

- [x] Criar repositório Git com pastas:
  - `/node_lugar/`
  - `/node_ala/`
  - `/gateway_pi/`
  - `/dashboard/`
  - `/relatorio/`

- [x] Criar `.gitignore` com regras para Arduino, Python e Node-RED / Flask.

- [x] Confirmar hardware final:
  - Arduino UNO R4 WiFi (um para nó de lugar, um para nó de ala).
  - Raspberry Pi.
  - Sensores ultrassónicos.
  - Sensor MQ-7 (CO) / qualidade do ar.
  - Ventoinha (fan) controlável via PWM ou relé.
  - LEDs.

---

## 1. Nó do lugar

**Corre em:** Arduino UNO R4 WiFi  
**Linguagem:** C/C++

Objetivo: decidir se o lugar está livre/ocupado e reportar isso.

Tarefas:
- [x] Ligar sensor ultrassónico ao Arduino.
- [x] Ligar LED verde/vermelho.
- [x] Medir distância “a vazio” e guardar como referência.
- [x] Fazer média de várias leituras para reduzir ruído.
- [x] Aplicar histerese:
  - se distância < (ref - margem_pequena) → ocupado.
  - se distância > (ref - margem_grande) → livre.
- [x] Atualizar LED (verde = livre, vermelho = ocupado).
- [x] Enviar mensagem (serial ou MQTT) com:
  - ID do lugar
  - estado_lugar (“livre” / “ocupado”)
  - timestamp simples (millis ou contador)

Output desta fase:  
1 lugar já sabe dizer “livre/ocupado” e manda essa info para o Pi.

---

## 2. Nó da ala

**Corre em:** Arduino UNO R4 WiFi  
**Linguagem:** C/C++

Objetivo: contar carros, manter ocupação da ala, ler ar, controlar ventoinha e sinalizar alertas.

### 2.1 Contagem entrada/saída (duas vias separadas)
- [x] Montar um sensor ultrassónico só na ENTRADA da ala.
- [x] Montar um sensor ultrassónico só na SAÍDA da ala.
- [x] Ler os dois sensores.
- [x] Se o sensor da ENTRADA detetar carro e não foi contado ainda → `ocupacao_ala++`.
- [x] Se o sensor da SAÍDA detetar carro e não foi contado ainda → `ocupacao_ala--` (nunca ir abaixo de 0).
- [x] Implementar debounce (ex.: ignorar novo carro no mesmo sensor durante ~300 ms para não contar duas vezes).
- [x] Sempre que `ocupacao_ala` muda, enviar pelo serial/MQTT algo tipo:
  - `{"evento":"entrada","total":12}`
  - `{"evento":"saida","total":11}`

### 2.2 Manter ocupação da ala
- [x] Guardar variável `ocupacao_ala` no Arduino da ala.
- [x] Garantir que não fica negativa.
- [x] Guardar timestamp da última atualização.


### 2.3 Qualidade do ar
- [x] Ligar o sensor MQ-7 (CO) ao analógico do Arduino da ala.
- [x] Ler o valor e guardar como `qualidade_ar` (valor relativo: quanto maior, pior).
- [x] Enviar periodicamente este valor para o Raspberry Pi.

### 2.4 Ventoinha
- [x] Ligar a ventoinha (fan) a um pino PWM (ou relé on/off).
- [x] Receber do Raspberry Pi um valor de velocidade (0–100%).
- [x] Aplicar esse valor via `analogWrite()` (PWM) ou ligar/desligar se for relé.
- [x] Enviar de volta para o Pi qual é a % atual.

### 2.5 Validação cruzada da ocupação
- [x] Receber do Raspberry Pi a soma dos lugares ocupados (vinda dos nós de lugar).
- [x] Comparar essa soma com `ocupacao_ala`.
- [x] Se a diferença for grande durante algum tempo → `alerta_sensor = true`.

### 2.6 Envio de dados para o Pi
- [x] Enviar em JSON:
  - `ocupacao_ala`
  - `qualidade_ar`
  - `ventoinha_percent`
  - `alerta_sensor`
  - timestamp

---

## 3. Gateway / Raspberry Pi

**Corre em:** Raspberry Pi  
**Linguagem:** Python

Tarefas:
- [x] Preparação do ambiente
  - [x] Instalar dependências (Python venv, paho-mqtt, sqlite3 client, tflite-runtime).
  - [x] Configurar serviço Mosquitto MQTT (topics locais para lugar, ala e cloud).
  - [x] Definir estrutura e localização da base SQLite (ficheiro, esquema de tabelas, índices).
- [x] Ingestão de dados
  - [x] Criar módulo Python que escuta MQTT/série dos Arduinos e normaliza mensagens.
  - [x] Persistir cada evento em SQLite com timestamp normalizado.
  - [x] Atualizar métricas em memória (ocupação, soma de lugares, qualidade do ar, ventoinha).
- [x] Sincronização com a cloud
  - [x] Agregar dados recentes (janelas de 30–60 s) e construir payload batch.
  - [x] Implementar publicador MQTT/HTTP seguro para enviar lotes à cloud.
  - [x] Implementar subscrição para receber comandos cloud → edge.
  - [x] Tratar mensagens cloud (`percent`, `lugares_ocupados`, overrides) e repassar para o nó da ala.
- [x] Previsão local (TinyML)
  - [x] Preparar dataset local (ocupação, hora/dia, fluxo de entrada) e exportar para o Tiny ML Kit.
  - [x] Treinar modelo no Tiny Machine Learning Kit (TensorFlow Lite Micro) e validar métricas.
  - [x] Converter modelo para `.tflite`, armazenar versão e copiar para o Pi.
  - [x] Implementar inferência com `tflite-runtime` no Pi (carregar modelo, executar previsões periódicas).
  - [x] Combinar previsão local com comandos da cloud e regras de segurança para gerar `percent` final.
- [x] Controlo e segurança
  - [x] Regras de segurança (qualidade_ar alta → ventoinha 100%, etc.).
  - [x] Carregar capacidade máxima da ala (config local/cloud) e calcular percentagem de ocupação.
  - [x] Enviar comandos resultantes para o nó da ala e confirmar ACK.
  - [x] Comparar `ocupacao_ala` vs `lugares_ocupados` e sinalizar `alerta_sensor` persistente.

### 3.1 Integração Cloud
- [x] Escolher plataforma (AWS IoT Core / Azure IoT Hub / Google IoT Core) e criar projeto.
- [x] Criar tópicos MQTT/REST (ex.: `pi/alaA/telemetry`, `cloud/alaA/commands`).
- [x] Configurar autenticação (certificados TLS/keys) e políticas de segurança.
- [x] Implementar função/broker para gravar dados em DB gerida (Timestream/DynamoDB, Cosmos DB, Firestore...).
- [x] Criar API/endpoint para devolver comandos ou previsões ao Pi.
- [x] Definir estratégia de retenção e limpeza de dados históricos.

### 3.2 TinyML / Machine Learning
- [ ] Captar dataset inicial (mínimo 24 h) para treino.
- [ ] Pré-processar dados no PC/Pi (normalização, features de tempo, fluxo acumulado).
- [ ] Treinar modelo no Tiny Machine Learning Kit (TensorFlow Lite Micro) e salvar logs.
- [ ] Avaliar modelo (RMSE/MAE) e iterar se necessário.
- [ ] Converter para `.tflite` otimizado e versionar.
- [ ] Automatizar processo de atualização: copiar novo modelo para o Pi e recarregar sem reboot.
- [ ] Planear re-treino periódico (manual ou triggered pela cloud quando existir novo dataset).

## 4. Dashboard e Visualização

**Opção cloud preferencial**  
- [ ] Selecionar ferramenta (Power BI, Grafana Cloud, Looker Studio ou web app próprio).
- [ ] Definir modelo de dados (vistas ocupação, qualidade ar, alertas, previsões).
- [ ] Configurar ligação à base cloud e atualizações em tempo real.
- [ ] Construir painéis:
  - [ ] Vista admin: ocupação por ala, `alerta_sensor`, qualidade do ar, ventoinha, previsões.
  - [ ] Vista utilizador: lugares livres por ala e tendências.
  - [ ] Cartões de alerta (“Ala A quase cheia”, “Qualidade do ar má”).
- [ ] Implementar autenticação/controlos de acesso.
- [ ] Publicar/partilhar dashboard e documentar instruções de acesso.

## 5. Testes

- [ ] Nó do lugar:
  - [ ] Meter/tirar objeto → LED muda e envia estado.
  - [ ] Verificar mensagem MQTT/serial com ID e timestamp corretos.
- [ ] Nó da ala:
  - [ ] Passar objeto pelo sensor da ENTRADA → contador++ e JSON `entrada`.
  - [ ] Passar objeto pelo sensor da SAÍDA → contador-- e JSON `saida`.
  - [ ] Validar debounce (não contar duas vezes no mesmo movimento).
  - [ ] Forçar diferença entre `ocupacao_ala` e `lugares_ocupados` → `alerta_sensor` ativo após tempo definido.
  - [ ] Confirmar que ventoinha responde a `percent` e reporta estado.
- [ ] Gateway / TinyML / Cloud:
  - [ ] Testar pipeline de ingestão Pi → DB local.
  - [ ] Verificar envio batch Pi → cloud e armazenamento correto.
  - [ ] Enviar comando cloud → Pi → nó da ala (latência e ACK).
  - [ ] Executar inferência TinyML com dados reais (comparar previsão vs ocupação medida).
  - [ ] Simular override cloud e garantir que regras de segurança prevalecem.
- [ ] Dashboard:
  - [ ] Visualizar métricas em tempo real.
  - [ ] Validar previsões/local vs cloud.
  - [ ] Verificar alertas e mensagens para utilizador/admin.

## 6. Relatório / apresentação

- [ ] Explicar o problema que estamos a resolver (gestão de parque por alas + qualidade do ar).
- [ ] Mostrar a arquitetura (nó do lugar → nó da ala → Pi → cloud → dashboard).
- [ ] Dizer que corre em Arduino (C/C++), Raspberry Pi (Python + TinyML) e cloud.
- [ ] Mostrar capturas do dashboard cloud.
- [ ] Explicar previsão + ventilação feed-forward + papel do TinyML.
- [ ] Falar de limitações:
  - usamos MQ-7 (CO) como aproximação, não CO₂ real
  - segurança MQTT básica
  - só uma ala / protótipo
  - sincronização com a cloud feita em modo batch

---

## 7. Objetivo final de demo

No fim queremos mostrar ao professor:

1. Um lugar que sabe dizer “livre/ocupado”, acende LED e envia esse estado.
2. Uma ala com ENTRADA e SAÍDA separadas que mantém `ocupacao_ala` com ++ / --.
3. O sistema a detetar diferença entre `ocupacao_ala` e soma dos lugares ocupados, e marcar alerta.
4. O Raspberry Pi a prever que a ala vai encher e a mandar subir a ventoinha antes do ar ficar mau.
5. O dashboard com tudo em tempo real.

Se estes 5 pontos funcionarem, o projeto está sólido. # 0, ja esta feita
